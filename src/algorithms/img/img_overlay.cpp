
// #include "stdafx.h"

#include "../image_transform_base.h"

#include "img_overlay.h"
#include "../by8/by8_base.h"

#pragma warning ( disable : 4127 )

//using namespace img;
using namespace img::overlay;

namespace
{
	//
	// g_FontData:
	//
	// The following is an 8x8 bit mapped font for use in the text overlay
	// code.
	//
	static const unsigned char g_FontData [256][8] = {
		{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
		{0x7e, 0x81, 0xa5, 0x81, 0xbd, 0x99, 0x81, 0x7e},
		{0x7e, 0xff, 0xdb, 0xff, 0xc3, 0xe7, 0xff, 0x7e},
		{0x6c, 0xfe, 0xfe, 0xfe, 0x7c, 0x38, 0x10, 0x00},
		{0x10, 0x38, 0x7c, 0xfe, 0x7c, 0x38, 0x10, 0x00},
		{0x38, 0x7c, 0x38, 0xfe, 0xfe, 0x7c, 0x38, 0x7c},
		{0x10, 0x10, 0x38, 0x7c, 0xfe, 0x7c, 0x38, 0x7c},
		{0x00, 0x00, 0x18, 0x3c, 0x3c, 0x18, 0x00, 0x00},
		{0xff, 0xff, 0xe7, 0xc3, 0xc3, 0xe7, 0xff, 0xff},
		{0x00, 0x3c, 0x66, 0x42, 0x42, 0x66, 0x3c, 0x00},
		{0xff, 0xc3, 0x99, 0xbd, 0xbd, 0x99, 0xc3, 0xff},
		{0x0f, 0x07, 0x0f, 0x7d, 0xcc, 0xcc, 0xcc, 0x78},
		{0x3c, 0x66, 0x66, 0x66, 0x3c, 0x18, 0x7e, 0x18},
		{0x3f, 0x33, 0x3f, 0x30, 0x30, 0x70, 0xf0, 0xe0},
		{0x7f, 0x63, 0x7f, 0x63, 0x63, 0x67, 0xe6, 0xc0},
		{0x99, 0x5a, 0x3c, 0xe7, 0xe7, 0x3c, 0x5a, 0x99},
		{0x80, 0xe0, 0xf8, 0xfe, 0xf8, 0xe0, 0x80, 0x00},
		{0x02, 0x0e, 0x3e, 0xfe, 0x3e, 0x0e, 0x02, 0x00},
		{0x18, 0x3c, 0x7e, 0x18, 0x18, 0x7e, 0x3c, 0x18},
		{0x66, 0x66, 0x66, 0x66, 0x66, 0x00, 0x66, 0x00},
		{0x7f, 0xdb, 0xdb, 0x7b, 0x1b, 0x1b, 0x1b, 0x00},
		{0x3e, 0x63, 0x38, 0x6c, 0x6c, 0x38, 0xcc, 0x78},
		{0x00, 0x00, 0x00, 0x00, 0x7e, 0x7e, 0x7e, 0x00},
		{0x18, 0x3c, 0x7e, 0x18, 0x7e, 0x3c, 0x18, 0xff},
		{0x18, 0x3c, 0x7e, 0x18, 0x18, 0x18, 0x18, 0x00},
		{0x18, 0x18, 0x18, 0x18, 0x7e, 0x3c, 0x18, 0x00},
		{0x00, 0x18, 0x0c, 0xfe, 0x0c, 0x18, 0x00, 0x00},
		{0x00, 0x30, 0x60, 0xfe, 0x60, 0x30, 0x00, 0x00},
		{0x00, 0x00, 0xc0, 0xc0, 0xc0, 0xfe, 0x00, 0x00},
		{0x00, 0x24, 0x66, 0xff, 0x66, 0x24, 0x00, 0x00},
		{0x00, 0x18, 0x3c, 0x7e, 0xff, 0xff, 0x00, 0x00},
		{0x00, 0xff, 0xff, 0x7e, 0x3c, 0x18, 0x00, 0x00},
		{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
		{0x30, 0x78, 0x78, 0x30, 0x30, 0x00, 0x30, 0x00},
		{0x6c, 0x6c, 0x6c, 0x00, 0x00, 0x00, 0x00, 0x00},
		{0x6c, 0x6c, 0xfe, 0x6c, 0xfe, 0x6c, 0x6c, 0x00},
		{0x30, 0x7c, 0xc0, 0x78, 0x0c, 0xf8, 0x30, 0x00},
		{0x00, 0xc6, 0xcc, 0x18, 0x30, 0x66, 0xc6, 0x00},
		{0x38, 0x6c, 0x38, 0x76, 0xdc, 0xcc, 0x76, 0x00},
		{0x60, 0x60, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00},
		{0x18, 0x30, 0x60, 0x60, 0x60, 0x30, 0x18, 0x00},
		{0x60, 0x30, 0x18, 0x18, 0x18, 0x30, 0x60, 0x00},
		{0x00, 0x66, 0x3c, 0xff, 0x3c, 0x66, 0x00, 0x00},
		{0x00, 0x30, 0x30, 0xfc, 0x30, 0x30, 0x00, 0x00},
		{0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x60},
		{0x00, 0x00, 0x00, 0xfc, 0x00, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x00},
		{0x06, 0x0c, 0x18, 0x30, 0x60, 0xc0, 0x80, 0x00},
		{0x7c, 0xc6, 0xce, 0xde, 0xf6, 0xe6, 0x7c, 0x00},
		{0x30, 0x70, 0x30, 0x30, 0x30, 0x30, 0xfc, 0x00},
		{0x78, 0xcc, 0x0c, 0x38, 0x60, 0xcc, 0xfc, 0x00},
		{0x78, 0xcc, 0x0c, 0x38, 0x0c, 0xcc, 0x78, 0x00},
		{0x1c, 0x3c, 0x6c, 0xcc, 0xfe, 0x0c, 0x1e, 0x00},
		{0xfc, 0xc0, 0xf8, 0x0c, 0x0c, 0xcc, 0x78, 0x00},
		{0x38, 0x60, 0xc0, 0xf8, 0xcc, 0xcc, 0x78, 0x00},
		{0xfc, 0xcc, 0x0c, 0x18, 0x30, 0x30, 0x30, 0x00},
		{0x78, 0xcc, 0xcc, 0x78, 0xcc, 0xcc, 0x78, 0x00},
		{0x78, 0xcc, 0xcc, 0x7c, 0x0c, 0x18, 0x70, 0x00},
		{0x00, 0x30, 0x30, 0x00, 0x00, 0x30, 0x30, 0x00},
		{0x00, 0x30, 0x30, 0x00, 0x00, 0x30, 0x30, 0x60},
		{0x18, 0x30, 0x60, 0xc0, 0x60, 0x30, 0x18, 0x00},
		{0x00, 0x00, 0xfc, 0x00, 0x00, 0xfc, 0x00, 0x00},
		{0x60, 0x30, 0x18, 0x0c, 0x18, 0x30, 0x60, 0x00},
		{0x78, 0xcc, 0x0c, 0x18, 0x30, 0x00, 0x30, 0x00},
		{0x7c, 0xc6, 0xde, 0xde, 0xde, 0xc0, 0x78, 0x00},
		{0x30, 0x78, 0xcc, 0xcc, 0xfc, 0xcc, 0xcc, 0x00},
		{0xfc, 0x66, 0x66, 0x7c, 0x66, 0x66, 0xfc, 0x00},
		{0x3c, 0x66, 0xc0, 0xc0, 0xc0, 0x66, 0x3c, 0x00},
		{0xf8, 0x6c, 0x66, 0x66, 0x66, 0x6c, 0xf8, 0x00},
		{0xfe, 0x62, 0x68, 0x78, 0x68, 0x62, 0xfe, 0x00},
		{0xfe, 0x62, 0x68, 0x78, 0x68, 0x60, 0xf0, 0x00},
		{0x3c, 0x66, 0xc0, 0xc0, 0xce, 0x66, 0x3e, 0x00},
		{0xcc, 0xcc, 0xcc, 0xfc, 0xcc, 0xcc, 0xcc, 0x00},
		{0x78, 0x30, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00},
		{0x1e, 0x0c, 0x0c, 0x0c, 0xcc, 0xcc, 0x78, 0x00},
		{0xe6, 0x66, 0x6c, 0x78, 0x6c, 0x66, 0xe6, 0x00},
		{0xf0, 0x60, 0x60, 0x60, 0x62, 0x66, 0xfe, 0x00},
		{0xc6, 0xee, 0xfe, 0xfe, 0xd6, 0xc6, 0xc6, 0x00},
		{0xc6, 0xe6, 0xf6, 0xde, 0xce, 0xc6, 0xc6, 0x00},
		{0x38, 0x6c, 0xc6, 0xc6, 0xc6, 0x6c, 0x38, 0x00},
		{0xfc, 0x66, 0x66, 0x7c, 0x60, 0x60, 0xf0, 0x00},
		{0x78, 0xcc, 0xcc, 0xcc, 0xdc, 0x78, 0x1c, 0x00},
		{0xfc, 0x66, 0x66, 0x7c, 0x6c, 0x66, 0xe6, 0x00},
		{0x78, 0xcc, 0xe0, 0x70, 0x1c, 0xcc, 0x78, 0x00},
		{0xfc, 0xb4, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00},
		{0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xfc, 0x00},
		{0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0x78, 0x30, 0x00},
		{0xc6, 0xc6, 0xc6, 0xd6, 0xfe, 0xee, 0xc6, 0x00},
		{0xc6, 0xc6, 0x6c, 0x38, 0x38, 0x6c, 0xc6, 0x00},
		{0xcc, 0xcc, 0xcc, 0x78, 0x30, 0x30, 0x78, 0x00},
		{0xfe, 0xc6, 0x8c, 0x18, 0x32, 0x66, 0xfe, 0x00},
		{0x78, 0x60, 0x60, 0x60, 0x60, 0x60, 0x78, 0x00},
		{0xc0, 0x60, 0x30, 0x18, 0x0c, 0x06, 0x02, 0x00},
		{0x78, 0x18, 0x18, 0x18, 0x18, 0x18, 0x78, 0x00},
		{0x10, 0x38, 0x6c, 0xc6, 0x00, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff},
		{0x30, 0x30, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0x78, 0x0c, 0x7c, 0xcc, 0x76, 0x00},
		{0xe0, 0x60, 0x60, 0x7c, 0x66, 0x66, 0xdc, 0x00},
		{0x00, 0x00, 0x78, 0xcc, 0xc0, 0xcc, 0x78, 0x00},
		{0x1c, 0x0c, 0x0c, 0x7c, 0xcc, 0xcc, 0x76, 0x00},
		{0x00, 0x00, 0x78, 0xcc, 0xfc, 0xc0, 0x78, 0x00},
		{0x38, 0x6c, 0x60, 0xf0, 0x60, 0x60, 0xf0, 0x00},
		{0x00, 0x00, 0x76, 0xcc, 0xcc, 0x7c, 0x0c, 0xf8},
		{0xe0, 0x60, 0x6c, 0x76, 0x66, 0x66, 0xe6, 0x00},
		{0x30, 0x00, 0x70, 0x30, 0x30, 0x30, 0x78, 0x00},
		{0x0c, 0x00, 0x0c, 0x0c, 0x0c, 0xcc, 0xcc, 0x78},
		{0xe0, 0x60, 0x66, 0x6c, 0x78, 0x6c, 0xe6, 0x00},
		{0x70, 0x30, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00},
		{0x00, 0x00, 0xcc, 0xfe, 0xfe, 0xd6, 0xc6, 0x00},
		{0x00, 0x00, 0xf8, 0xcc, 0xcc, 0xcc, 0xcc, 0x00},
		{0x00, 0x00, 0x78, 0xcc, 0xcc, 0xcc, 0x78, 0x00},
		{0x00, 0x00, 0xdc, 0x66, 0x66, 0x7c, 0x60, 0xf0},
		{0x00, 0x00, 0x76, 0xcc, 0xcc, 0x7c, 0x0c, 0x1e},
		{0x00, 0x00, 0xdc, 0x76, 0x66, 0x60, 0xf0, 0x00},
		{0x00, 0x00, 0x7c, 0xc0, 0x78, 0x0c, 0xf8, 0x00},
		{0x10, 0x30, 0x7c, 0x30, 0x30, 0x34, 0x18, 0x00},
		{0x00, 0x00, 0xcc, 0xcc, 0xcc, 0xcc, 0x76, 0x00},
		{0x00, 0x00, 0xcc, 0xcc, 0xcc, 0x78, 0x30, 0x00},
		{0x00, 0x00, 0xc6, 0xd6, 0xfe, 0xfe, 0x6c, 0x00},
		{0x00, 0x00, 0xc6, 0x6c, 0x38, 0x6c, 0xc6, 0x00},
		{0x00, 0x00, 0xcc, 0xcc, 0xcc, 0x7c, 0x0c, 0xf8},
		{0x00, 0x00, 0xfc, 0x98, 0x30, 0x64, 0xfc, 0x00},
		{0x1c, 0x30, 0x30, 0xe0, 0x30, 0x30, 0x1c, 0x00},
		{0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x00},
		{0xe0, 0x30, 0x30, 0x1c, 0x30, 0x30, 0xe0, 0x00},
		{0x76, 0xdc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
		{0x00, 0x10, 0x38, 0x6c, 0xc6, 0xc6, 0xfe, 0x00},
		{0x78, 0xcc, 0xc0, 0xcc, 0x78, 0x18, 0x0c, 0x78},
		{0x00, 0xcc, 0x00, 0xcc, 0xcc, 0xcc, 0x7e, 0x00},
		{0x1c, 0x00, 0x78, 0xcc, 0xfc, 0xc0, 0x78, 0x00},
		{0x7e, 0xc3, 0x3c, 0x06, 0x3e, 0x66, 0x3f, 0x00},
		{0xcc, 0x00, 0x78, 0x0c, 0x7c, 0xcc, 0x7e, 0x00},
		{0xe0, 0x00, 0x78, 0x0c, 0x7c, 0xcc, 0x7e, 0x00},
		{0x30, 0x30, 0x78, 0x0c, 0x7c, 0xcc, 0x7e, 0x00},
		{0x00, 0x00, 0x78, 0xc0, 0xc0, 0x78, 0x0c, 0x38},
		{0x7e, 0xc3, 0x3c, 0x66, 0x7e, 0x60, 0x3c, 0x00},
		{0xcc, 0x00, 0x78, 0xcc, 0xfc, 0xc0, 0x78, 0x00},
		{0xe0, 0x00, 0x78, 0xcc, 0xfc, 0xc0, 0x78, 0x00},
		{0xcc, 0x00, 0x70, 0x30, 0x30, 0x30, 0x78, 0x00},
		{0x7c, 0xc6, 0x38, 0x18, 0x18, 0x18, 0x3c, 0x00},
		{0xe0, 0x00, 0x70, 0x30, 0x30, 0x30, 0x78, 0x00},
		{0xc6, 0x38, 0x6c, 0xc6, 0xfe, 0xc6, 0xc6, 0x00},
		{0x30, 0x30, 0x00, 0x78, 0xcc, 0xfc, 0xcc, 0x00},
		{0x1c, 0x00, 0xfc, 0x60, 0x78, 0x60, 0xfc, 0x00},
		{0x00, 0x00, 0x7f, 0x0c, 0x7f, 0xcc, 0x7f, 0x00},
		{0x3e, 0x6c, 0xcc, 0xfe, 0xcc, 0xcc, 0xce, 0x00},
		{0x78, 0xcc, 0x00, 0x78, 0xcc, 0xcc, 0x78, 0x00},
		{0x00, 0xcc, 0x00, 0x78, 0xcc, 0xcc, 0x78, 0x00},
		{0x00, 0xe0, 0x00, 0x78, 0xcc, 0xcc, 0x78, 0x00},
		{0x78, 0xcc, 0x00, 0xcc, 0xcc, 0xcc, 0x7e, 0x00},
		{0x00, 0xe0, 0x00, 0xcc, 0xcc, 0xcc, 0x7e, 0x00},
		{0x00, 0xcc, 0x00, 0xcc, 0xcc, 0x7c, 0x0c, 0xf8},
		{0xc3, 0x18, 0x3c, 0x66, 0x66, 0x3c, 0x18, 0x00},
		{0xcc, 0x00, 0xcc, 0xcc, 0xcc, 0xcc, 0x78, 0x00},
		{0x18, 0x18, 0x7e, 0xc0, 0xc0, 0x7e, 0x18, 0x18},
		{0x38, 0x6c, 0x64, 0xf0, 0x60, 0xe6, 0xfc, 0x00},
		{0xcc, 0xcc, 0x78, 0xfc, 0x30, 0xfc, 0x30, 0x30},
		{0xf8, 0xcc, 0xcc, 0xfa, 0xc6, 0xcf, 0xc6, 0xc7},
		{0x0e, 0x1b, 0x18, 0x3c, 0x18, 0x18, 0xd8, 0x70},
		{0x1c, 0x00, 0x78, 0x0c, 0x7c, 0xcc, 0x7e, 0x00},
		{0x38, 0x00, 0x70, 0x30, 0x30, 0x30, 0x78, 0x00},
		{0x00, 0x1c, 0x00, 0x78, 0xcc, 0xcc, 0x78, 0x00},
		{0x00, 0x1c, 0x00, 0xcc, 0xcc, 0xcc, 0x7e, 0x00},
		{0x00, 0xf8, 0x00, 0xf8, 0xcc, 0xcc, 0xcc, 0x00},
		{0xfc, 0x00, 0xcc, 0xec, 0xfc, 0xdc, 0xcc, 0x00},
		{0x3c, 0x6c, 0x6c, 0x3e, 0x00, 0x7e, 0x00, 0x00},
		{0x38, 0x6c, 0x6c, 0x38, 0x00, 0x7c, 0x00, 0x00},
		{0x30, 0x00, 0x30, 0x60, 0xc0, 0xcc, 0x78, 0x00},
		{0x00, 0x00, 0x00, 0xfc, 0xc0, 0xc0, 0x00, 0x00},
		{0x00, 0x00, 0x00, 0xfc, 0x0c, 0x0c, 0x00, 0x00},
		{0xc3, 0xc6, 0xcc, 0xde, 0x33, 0x66, 0xcc, 0x0f},
		{0xc3, 0xc6, 0xcc, 0xdb, 0x37, 0x6f, 0xcf, 0x03},
		{0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x18, 0x00},
		{0x00, 0x33, 0x66, 0xcc, 0x66, 0x33, 0x00, 0x00},
		{0x00, 0xcc, 0x66, 0x33, 0x66, 0xcc, 0x00, 0x00},
		{0x22, 0x88, 0x22, 0x88, 0x22, 0x88, 0x22, 0x88},
		{0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa},
		{0xdb, 0x77, 0xdb, 0xee, 0xdb, 0x77, 0xdb, 0xee},
		{0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18},
		{0x18, 0x18, 0x18, 0x18, 0xf8, 0x18, 0x18, 0x18},
		{0x18, 0x18, 0xf8, 0x18, 0xf8, 0x18, 0x18, 0x18},
		{0x36, 0x36, 0x36, 0x36, 0xf6, 0x36, 0x36, 0x36},
		{0x00, 0x00, 0x00, 0x00, 0xfe, 0x36, 0x36, 0x36},
		{0x00, 0x00, 0xf8, 0x18, 0xf8, 0x18, 0x18, 0x18},
		{0x36, 0x36, 0xf6, 0x06, 0xf6, 0x36, 0x36, 0x36},
		{0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36},
		{0x00, 0x00, 0xfe, 0x06, 0xf6, 0x36, 0x36, 0x36},
		{0x36, 0x36, 0xf6, 0x06, 0xfe, 0x00, 0x00, 0x00},
		{0x36, 0x36, 0x36, 0x36, 0xfe, 0x00, 0x00, 0x00},
		{0x18, 0x18, 0xf8, 0x18, 0xf8, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0x00, 0x00, 0xf8, 0x18, 0x18, 0x18},
		{0x18, 0x18, 0x18, 0x18, 0x1f, 0x00, 0x00, 0x00},
		{0x18, 0x18, 0x18, 0x18, 0xff, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0x00, 0x00, 0xff, 0x18, 0x18, 0x18},
		{0x18, 0x18, 0x18, 0x18, 0x1f, 0x18, 0x18, 0x18},
		{0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00},
		{0x18, 0x18, 0x18, 0x18, 0xff, 0x18, 0x18, 0x18},
		{0x18, 0x18, 0x1f, 0x18, 0x1f, 0x18, 0x18, 0x18},
		{0x36, 0x36, 0x36, 0x36, 0x37, 0x36, 0x36, 0x36},
		{0x36, 0x36, 0x37, 0x30, 0x3f, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0x3f, 0x30, 0x37, 0x36, 0x36, 0x36},
		{0x36, 0x36, 0xf7, 0x00, 0xff, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0xff, 0x00, 0xf7, 0x36, 0x36, 0x36},
		{0x36, 0x36, 0x37, 0x30, 0x37, 0x36, 0x36, 0x36},
		{0x00, 0x00, 0xff, 0x00, 0xff, 0x00, 0x00, 0x00},
		{0x36, 0x36, 0xf7, 0x00, 0xf7, 0x36, 0x36, 0x36},
		{0x18, 0x18, 0xff, 0x00, 0xff, 0x00, 0x00, 0x00},
		{0x36, 0x36, 0x36, 0x36, 0xff, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0xff, 0x00, 0xff, 0x18, 0x18, 0x18},
		{0x00, 0x00, 0x00, 0x00, 0xff, 0x36, 0x36, 0x36},
		{0x36, 0x36, 0x36, 0x36, 0x3f, 0x00, 0x00, 0x00},
		{0x18, 0x18, 0x1f, 0x18, 0x1f, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0x1f, 0x18, 0x1f, 0x18, 0x18, 0x18},
		{0x00, 0x00, 0x00, 0x00, 0x3f, 0x36, 0x36, 0x36},
		{0x36, 0x36, 0x36, 0x36, 0xff, 0x36, 0x36, 0x36},
		{0x18, 0x18, 0xff, 0x18, 0xff, 0x18, 0x18, 0x18},
		{0x18, 0x18, 0x18, 0x18, 0xf8, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0x00, 0x00, 0x1f, 0x18, 0x18, 0x18},
		{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff},
		{0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff},
		{0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0},
		{0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f},
		{0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0x76, 0xdc, 0xc8, 0xdc, 0x76, 0x00},
		{0x00, 0x78, 0xcc, 0xf8, 0xcc, 0xf8, 0xc0, 0xc0},
		{0x00, 0xfc, 0xcc, 0xc0, 0xc0, 0xc0, 0xc0, 0x00},
		{0x00, 0xfe, 0x6c, 0x6c, 0x6c, 0x6c, 0x6c, 0x00},
		{0xfc, 0xcc, 0x60, 0x30, 0x60, 0xcc, 0xfc, 0x00},
		{0x00, 0x00, 0x7e, 0xd8, 0xd8, 0xd8, 0x70, 0x00},
		{0x00, 0x66, 0x66, 0x66, 0x66, 0x7c, 0x60, 0xc0},
		{0x00, 0x76, 0xdc, 0x18, 0x18, 0x18, 0x18, 0x00},
		{0xfc, 0x30, 0x78, 0xcc, 0xcc, 0x78, 0x30, 0xfc},
		{0x38, 0x6c, 0xc6, 0xfe, 0xc6, 0x6c, 0x38, 0x00},
		{0x38, 0x6c, 0xc6, 0xc6, 0x6c, 0x6c, 0xee, 0x00},
		{0x1c, 0x30, 0x18, 0x7c, 0xcc, 0xcc, 0x78, 0x00},
		{0x00, 0x00, 0x7e, 0xdb, 0xdb, 0x7e, 0x00, 0x00},
		{0x06, 0x0c, 0x7e, 0xdb, 0xdb, 0x7e, 0x60, 0xc0},
		{0x38, 0x60, 0xc0, 0xf8, 0xc0, 0x60, 0x38, 0x00},
		{0x78, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0x00},
		{0x00, 0xfc, 0x00, 0xfc, 0x00, 0xfc, 0x00, 0x00},
		{0x30, 0x30, 0xfc, 0x30, 0x30, 0x00, 0xfc, 0x00},
		{0x60, 0x30, 0x18, 0x30, 0x60, 0x00, 0xfc, 0x00},
		{0x18, 0x30, 0x60, 0x30, 0x18, 0x00, 0xfc, 0x00},
		{0x0e, 0x1b, 0x1b, 0x18, 0x18, 0x18, 0x18, 0x18},
		{0x18, 0x18, 0x18, 0x18, 0x18, 0xd8, 0xd8, 0x70},
		{0x30, 0x30, 0x00, 0xfc, 0x00, 0x30, 0x30, 0x00},
		{0x00, 0x76, 0xdc, 0x00, 0x76, 0xdc, 0x00, 0x00},
		{0x38, 0x6c, 0x6c, 0x38, 0x00, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00},
		{0x0f, 0x0c, 0x0c, 0x0c, 0xec, 0x6c, 0x3c, 0x1c},
		{0x78, 0x6c, 0x6c, 0x6c, 0x6c, 0x00, 0x00, 0x00},
		{0x70, 0x18, 0x30, 0x60, 0x78, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0x3c, 0x3c, 0x3c, 0x3c, 0x00, 0x00},
		{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
	};

	struct RGB32Str
	{
		byte	b,g,r,a;

		static const bool	bBottomUp = true;
	};
    struct RGB64Str
    {
        uint16_t	b, g, r, a;

        static const bool	bBottomUp = true;
    };
	struct RGB24Str
	{
		byte	b,g,r;
		static const bool	bBottomUp = true;
	};
	struct Y800Str
	{
		byte 	y;
		static const bool	bBottomUp = false;
	};
	struct YGB0Str
	{
		uint16_t 	y;
		static const bool	bBottomUp = false;
	};
	struct Y16Str
	{
		uint16_t y;
		static const bool	bBottomUp = false;
	};
	struct UYVYStr
	{
		byte 	y;
	};

	const RGB32Str rgb32_Color_table[MAX_COLOR] = {
		{0, 0, 0},          // BLACK
		{255, 255, 255},    // WHITE
		{0, 255, 255},      // YELLOW
		{255, 255, 0},      // CYAN
		{0, 255, 0},        // GREEN
		{255, 0, 255},      // MAGENTA
		{0, 0, 255},        // RED
		{255, 0, 0},        // BLUE
		{128, 128, 128}     // GREY
	};

#define RGB24ToY800Color(r,g,b)		((0.299f * r) + (0.587f * g) + (0.114f * b)) > 255 ?	\
											255 :	\
											((byte)((0.299f * r) + (0.587f * g) + (0.114f * b)))


	const Y800Str y8_Color_table[MAX_COLOR] =
	{
		0,			// BLACK
		255,		// WHITE
		RGB24ToY800Color(0, 255, 255),      // YELLOW
		RGB24ToY800Color(255, 255, 0),      // CYAN
		RGB24ToY800Color(0, 255, 0),        // GREEN
		RGB24ToY800Color(255, 0, 255),      // MAGENTA
		RGB24ToY800Color(0, 0, 255),        // RED
		RGB24ToY800Color(255, 0, 0),        // BLUE
		128			// GREY
	};

	template<class TDestPixelType>
	TDestPixelType	pixel_transform( COLOR clr );

	template<>
	RGB32Str	pixel_transform<RGB32Str>( COLOR clr )
	{
		return rgb32_Color_table[clr];
	}
	template<>
	RGB24Str	pixel_transform<RGB24Str>( COLOR clr )
	{
		RGB24Str str = { rgb32_Color_table[clr].b, rgb32_Color_table[clr].g, rgb32_Color_table[clr].r };
		return str;
	}
    template<>
    RGB64Str	pixel_transform<RGB64Str>( COLOR clr )
    {
        RGB64Str str = { rgb32_Color_table[clr].b << 8, rgb32_Color_table[clr].g << 8, rgb32_Color_table[clr].r << 8 };
        return str;
    }
	template<>
	Y800Str	pixel_transform<Y800Str>( COLOR clr )
	{
		return y8_Color_table[clr];
	}

	uint16_t YGB0PixelFromInt16Value( uint16_t value )
	{
		uint16_t v = (value << 6);
		return (v >> 8) | (v << 8);
	}

	template<>
	YGB0Str	pixel_transform<YGB0Str>( COLOR clr )
	{
		YGB0Str rval = { YGB0PixelFromInt16Value( y8_Color_table[clr].y * 4 ) };
		return rval;
	}

	template<>
	Y16Str	pixel_transform<Y16Str>( COLOR clr )
	{
		Y16Str rval = { uint16_t(y8_Color_table[clr].y * 256) };
		return rval;
	}

	template<typename TStruct>
	struct clr_iter
	{
		static const unsigned int step_size = sizeof( TStruct );

		clr_iter( img::img_descriptor& d, POINT pos, bool bUserFlip ) : data( d ), pCursor( d.pData )
		{
			bool bFlip = TStruct::bBottomUp ^ bUserFlip;
			if( bFlip )
				pCursor += (d.dim_y - pos.y - 1) * d.pitch + pos.x * step_size;
			else
				pCursor += pos.y * d.pitch + pos.x * step_size;
		}

		clr_iter	operator++( int )	{ clr_iter tmp( *this ); pCursor += step_size; return tmp; }

		struct conv_helper : TStruct
		{
			conv_helper&	operator=( COLOR clr )
			{
				if( clr != TRANSPARENT_CLR )
					((TStruct&)*this) = pixel_transform<TStruct>( clr );
				return *this;
			}
		};

		conv_helper&	operator*()			{ return *(conv_helper*)pCursor; }
	private:
		void	operator=( const clr_iter& );

		img::img_descriptor&	data;
		byte*		pCursor;
	};

    static const unsigned char yuv_Colors[MAX_COLOR][3] = {
            { 128, 16, 128 },     // BLACK
            { 128, 235, 128 },    // WHITE
            { 16, 211, 146 },     // YELLOW
            { 166, 170, 16 },     // CYAN
            { 54, 145, 34 },      // GREEN
            { 202, 106, 222 },    // MAGENTA
            { 90, 81, 240 },      // RED
            { 240, 41, 109 },     // BLUE
            { 128, 125, 128 },    // GREY
    };

	template<uint32_t fcc>
	struct yuv_iter
	{
		yuv_iter( img::img_descriptor& d, POINT pos, bool bUserFlip ) : data( d ), pCursor( d.pData )
		{
			unsigned int step_size = 4;

			bool bFlip = bUserFlip;
			if( bFlip )
				pCursor += (d.dim_y - pos.y - 1) * d.pitch + pos.x * step_size;
			else
				pCursor += pos.y * d.pitch + pos.x * step_size;

			parity = (pos.x % 2) != 0;
		}

		yuv_iter	operator++( int )
		{
			yuv_iter tmp( *this );
			if( parity ) { pCursor += 4; }
			parity = !parity;
			return tmp;
		}

		struct conv_helper_yuyv
		{
			conv_helper_yuyv( byte* pPos, bool parity ) : pCursor( pPos ), bParity( parity )	{}
			conv_helper_yuyv&	operator=( COLOR clr )
			{

				if( clr != TRANSPARENT_CLR )
				{
					// [0] => y
					// [1] => u
					// [2] => y
					// [3] => v
					if( fcc == FOURCC_UYVY )
					{
						if (bParity) {
							pCursor[2] = yuv_Colors[clr][2];
						} else {
							pCursor[1] = yuv_Colors[clr][1];
							pCursor[0] = yuv_Colors[clr][0];
							pCursor[3] = yuv_Colors[clr][1];
						}
					}
					else if( fcc == FOURCC_YUY2 )
					{
						if (bParity) {
							pCursor[3] = yuv_Colors[clr][2];
						} else {
							pCursor[0] = yuv_Colors[clr][1];
							pCursor[1] = yuv_Colors[clr][0];
							pCursor[2] = yuv_Colors[clr][1];
						}
					}
				}
				return *this;
			}
			byte* 	pCursor;
			bool 	bParity;
		};

		conv_helper_yuyv		operator*()			{ return conv_helper_yuyv( pCursor, parity ); }
	private:
		void	operator=( const yuv_iter& );
		img::img_descriptor&		data;
		byte*			pCursor;
		bool			parity;
	};

template<typename TIter>
void	render_worker( img::img_descriptor& data, POINT pos, unsigned int scaling, const char* pText,
					  COLOR BgColor, COLOR FgColor, unsigned int LenX, bool bFlip )
{
	//
	// Determine the amount of space available on the synthesis buffer.
	// We will clip anything that finds itself outside the synthesis buffer.
	//
	unsigned int SpaceX = data.dim_x - pos.x;
	unsigned int SpaceY = data.dim_y - pos.y;

	//
	// Overlay a background color row.
	//
	if (BgColor != TRANSPARENT_CLR && SpaceY) {
		TIter iter( data, pos, bFlip );
		for ( unsigned int x = 0; x < LenX && x < SpaceX; x++) {
			*iter++ = BgColor;
		}
	}
	pos.y++;
	if(SpaceY) SpaceY--;

	//
	// Loop across each row of the image.
	//
	for( unsigned int row = 0; row < 8 && SpaceY; row++ ) {
		for( unsigned int scalerY = 0; scalerY < scaling && SpaceY; ++scalerY )
		{
			//
			// Generate a line.
			//
			TIter iter( data, pos, bFlip );

			unsigned int CurSpaceX = SpaceX;
			// prefix bg clr
			if (CurSpaceX) {
				*iter++ = BgColor;
				CurSpaceX--;
			}

			//
			// Generate the row'th row of the overlay.
			//
			const char* CurChar = pText;
			while (CurChar && *CurChar) {
				unsigned char CharBase = g_FontData[*CurChar++][row];
				for( unsigned int mask = 0x80; mask && CurSpaceX; mask >>= 1 ) {
					for( unsigned int scalerX = 0; scalerX < scaling && CurSpaceX; ++scalerX )
					{
						if( CharBase & mask ) {
							*iter++ = FgColor;
						} else {
							*iter++ = BgColor;
						}
						CurSpaceX--;
					}
				}

				//
				// Separate each character by one space.  Account for the border
				// space at the end by placing the separator after the last
				// character also.
				//
				if (CurSpaceX) {
					*iter++ = BgColor;
					CurSpaceX--;
				}
			}
			++pos.y;
			--SpaceY;
		}
	}

	//
	// Add the bottom section of the overlay.
	//
	if (BgColor != TRANSPARENT_CLR && SpaceY) {
		TIter iter( data, pos, bFlip );
		for (unsigned int x = 0; x < LenX && x < SpaceX; x++) {
			*iter++ = BgColor;
		}
	}
}
};

void	img::overlay::RenderText( img_descriptor& data, POINT pos, unsigned int scaling, const char* pText,
								 COLOR BgColor, COLOR FgColor, bool bFlip )
{
    //
    // Determine the character length of the string.
    //
	unsigned int StrLen = 0;
    for( const char* CurChar = pText; CurChar && *CurChar; CurChar++ )
        StrLen++;

	unsigned int height = data.dim_y;

	if( (int(data.dim_x) - pos.x) <= 0 )		return;
	if( (int(data.dim_y) - pos.y) <= 0 )		return;

    //
    // Determine the physical size of the string plus border. One empty pixel
    // column is added between characters.
    //
    unsigned int LenX = (StrLen * (scaling << 3)) + 1 + StrLen;
	unsigned int LenY = 2 + (scaling << 3);


    //
    // Adjust for center overlays.
    //
    // NOTE: If the overlay doesn't fit into the synthesis buffer, this
    // merely left aligns the overlay and clips off the right side.
    //
    if (pos.x == POSITION_CENTER)
	{
        if (pos.x >= (int)data.dim_x) {
            pos.x = 0;
        } else {
            pos.x = (data.dim_x >> 1) - (LenX >> 1);
        }
    }
    if (pos.y == POSITION_CENTER)
	{
        if( LenY >= height ) {
            pos.y = 0;
        } else {
            pos.y = (height >> 1) - (LenY >> 1);
        }
    }
	if( data.type == FOURCC_RGB32 )
	{
		render_worker<clr_iter<RGB32Str> >( data, pos, scaling, pText, BgColor, FgColor, LenX, bFlip );
	}
    else if( data.type == FOURCC_RGB64 )
    {
        render_worker<clr_iter<RGB64Str> >( data, pos, scaling, pText, BgColor, FgColor, LenX, bFlip );
    }
	else if( data.type == FOURCC_RGB24 )
	{
		render_worker<clr_iter<RGB24Str> >( data, pos, scaling, pText, BgColor, FgColor, LenX, bFlip );
	}
	else if( data.type == FOURCC_Y800 )
	{
		render_worker<clr_iter<Y800Str> >( data, pos, scaling, pText, BgColor, FgColor, LenX, bFlip );
	}
	else if( data.type == FOURCC_UYVY )
	{
		render_worker<yuv_iter<FOURCC_UYVY> >( data, pos, scaling, pText, BgColor, FgColor, LenX, bFlip );
	}
	else if( data.type == FOURCC_YUY2 )
	{
		render_worker<yuv_iter<FOURCC_YUY2> >( data, pos, scaling, pText, BgColor, FgColor, LenX, bFlip );
	}
	else if( data.type == FOURCC_YGB0 )
	{
		render_worker<clr_iter<YGB0Str> >( data, pos, scaling, pText, BgColor, FgColor, LenX, bFlip );
	}
	else if( data.type == FOURCC_Y16 )
	{
		render_worker<clr_iter<Y16Str> >( data, pos, scaling, pText, BgColor, FgColor, LenX, bFlip );
	}
	else if( data.type == FOURCC_I420 || data.type == FOURCC_YV16 || data.type == FOURCC_YUV8PLANAR )
	{
        img::img_descriptor tmp_data = img::copy_img_desc( data, FOURCC_Y800 );
		render_worker<clr_iter<Y800Str> >( tmp_data, pos, scaling, pText, BgColor, FgColor, LenX, bFlip );
	}
    else if( data.type == FOURCC_YUV16PLANAR )
    {
        img::img_descriptor tmp_data = img::copy_img_desc( data, FOURCC_Y16 );
        render_worker<clr_iter<Y16Str> >( tmp_data, pos, scaling, pText, BgColor, FgColor, LenX, bFlip );
    }
	else if( img::isBayerFCC( data.type ) )
	{
		render_worker<clr_iter<Y800Str> >( data, pos, scaling, pText, BgColor, FgColor, LenX, bFlip );
	}
}
